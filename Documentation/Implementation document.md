# Implementation document

The different algorithms used in this program are all implemented in their own Java classes. These are controlled by the class called "Logic". The graphical user interface uses a Logic class to call different methods from the classes when the user clicks different buttons.

*insert class diagram*

The mazes that are generated and solved are two-dimensional character arrays with corridors and walls. This means that when the width is w and the height is h it actually means that the size of the two-dimensional array is (2w + 1) * (2h + 1) because there are walls between the corridors and on each side of the maze. In this document w always stands for the maze's width and h for its height.

Some of the algorithms use data structures like stacks and linked lists. These have been implemented in the package called "maze.data_structures".

# Maze generating algorithms

## Recursive backtracker


## Kruskal's algorithm
This maze generation method is based on creating a minimum spanning tree by connecting random nodes as long as it does not create a loop. In my implementation there are two things that the program keeps track of: rooms (nodes, marked as pink numbers) and potential corridors (edges, marked with blue circles around them).

![Kruskal implementation](https://raw.githubusercontent.com/H4m5t3r/Comparison-of-maze-solving-algorithms/master/Documentation/Pictures/Kruskal%20example.jpg)

When the algorithm starts it creates a two-dimensional character array that matches the size that the user has entered. All rooms (pink numbers) are marked with " " since the maze should cover the whole area and the rest are marked as walls with "#". After that a union-find structure with the same number of elements as the number of rooms (width * height) and an array with the same number of spaces as the number of potential corridors (blue circles) is created. The corridor array is shuffled so that the algorithm checks the corridors in a random order. When the program goes through the corridor array it checks if the rooms are above and below or to the left and right of it. After that it calculates the rooms' number and checks if they are already connected in the union-find structure. If not it connects them and replaces the wall ("#") in the two-dimensional character array with a blank space (" "). After all corridor spaces have been checked the entrance and exit is added to a random odd space on the first and last row.

The most complicated part in this process is the calculation of the adjacent rooms' id number. At first glance it may seem pretty confusing but there is always a relation between them and the number can be calculated as long as you know the height of the maze. The algorithm results in a time complexity of O((2h-1) * (2w - 1) +  2 * ((w - 1) * (2h - 1) + (h - 1))). The first two parentheses come from the generation of the base for the maze where all rooms are marked with ' ' and the rest of the spaces in the two-dimensional character array with '#'. After that the room list is shuffled (one shuffle for each corridor) and after that all the corridors are gone through once. (w - 1) * (2h - 1) + (h - 1) is the number of corridors.

# Maze solving algorithms

## Dead-end filling
The dead-end filling algorithms solves mazes by searching for dead-ends and filling them in until it reaches a crossroad. It works for perfect mazes and can therefore solve all the mazes generated by the recursive backtracker and the Kruskal algorithm. In my implementation there are 3 methods: solve, isDeadEnd and fillDeadEnd. The solve method starts going through all the rooms, checking if they are blank spaces. If they are the isDeadEnd method is called. It checks if the room is a dead-end by checking if the number of corridors going from it is equal to 1. If the requirement is filled the fillDeadEnd method is called. It fills in the room, checks where the corridor is, fills it in and calls the isDeadEnd method in the next room. This results in a time complexity of O(w * h + r) where w is the maze's width, h is the maze's height and r is the random number of extra times rooms are checked, since the algorithm goes through all the rooms, checking if they have alreay been visited. 

## Depth-first search

### Sources used in this project:

Maze solving algorithm, Wikipedia 2020, viewed 15.5.2020

https://en.wikipedia.org/wiki/Maze_solving_algorithm

Think Labyrinth: Daedalus

http://www.astrolog.org/labyrnth/daedalus.htm