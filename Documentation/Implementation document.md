# Implementation document

The different algorithms used in this program are all implemented in their own Java classes. These are controlled by the class called "Logic". The graphical user interface uses a Logic class to call different methods from the classes when the user clicks different buttons.

*insert class diagram*

The mazes that are generated and solved are two-dimensional character arrays with corridors and walls. This means that when the width is x and the height is y it actually means that the size of the two-dimensional array is (2x + 1) * (2y + 1) because there are walls between the corridors and on each side of the maze.

Some of the algorithms use data structures like stacks and linked lists. These have been implemented in the package called "maze.data_structures".

# Maze generating algorithms

## Recursive backtracker


## Kruskal's algorithm
This maze generation method is based on creating a minimum spanning tree by connecting random nodes as long as it does not create a loop. In my implementation there are two things that the program keeps track of: rooms (nodes, marked as pink numbers) and potential corridors (edges, marked with blue circles around them).

![Kruskal implementation](https://raw.githubusercontent.com/H4m5t3r/Comparison-of-maze-solving-algorithms/master/Documentation/Pictures/Kruskal%20example.jpg)

When the algorithm starts it creates a two-dimensional character array that matches the size that the user has entered. All rooms (pink numbers) are marked with " " since the maze should cover the whole area and the rest are marked as walls with "#". After that a union-find structure with the same number of elements as the number of rooms (width * height) and an array with the same number of spaces as the number of potential corridors (blue circles) is created. The corridor array is shuffled so that the algorithm checks the corridors in a random order. When the program goes through the corridor array it checks if the rooms are above and below or to the left and right of it. After that it calculates the rooms' number and checks if they are already connected in the union-find structure. If not it connects them and replaces the wall ("#") in the two-dimensional character array with a blank space (" "). After all corridor spaces have been checked the entrance and exit is added to a random odd space on the first and last row.

The most complicated part in this process is the calculation of the adjacent rooms' id number. At first glance it may seem pretty confusing but there is always a relation between them and the number can be calculated as long as you know the height of the maze.

# Maze solving algorithms

## Dead-end filling
The dead-end filling algorithms solves mazes by searching for dead-ends and filling them in until it reaches a crossroad. It works for perfect mazes and can therefore solve all the mazes generated by the recursive backtracker and the Kruskal algorithm. In the program it starts going through all the rooms while checking if they are dead-ends. If they are the filling algorithm is called

**Skulle kunna effektivera algoritmen med att inte ha den att gå igenom allt efter att den redan varit där.**

## Depth-first search

### Sources used in this project:

Maze solving algorithm, Wikipedia 2020, viewed 15.5.2020

https://en.wikipedia.org/wiki/Maze_solving_algorithm

Think Labyrinth: Daedalus

http://www.astrolog.org/labyrnth/daedalus.htm